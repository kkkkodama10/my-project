# Project Rules

このファイルはプロジェクト全体で遵守すべきルールを定義する。
AIエージェントおよび開発者は、コードの生成・レビュー・修正のすべてにおいてこのルールに従うこと。

---

## 1. 命名規則

### 原則: 可読性を最優先する。長い命名は許容する。

- 変数名・関数名・クラス名は、その役割や意図を読んだだけで理解できる名前にすること
- 省略形は原則禁止（`usr` → `user`、`btn` → `button`、`msg` → `message`）
- 業界で広く通用する略語のみ例外とする（`id`、`url`、`http`、`api`、`db` など）
- 真偽値は `is`、`has`、`can`、`should` などのプレフィックスを使う
  - 例: `isVisible`、`hasPermission`、`canExecute`
- コレクションは複数形にする
  - 例: `users`、`orderItems`、`validationErrors`
- コールバックやイベントハンドラは `on` または `handle` プレフィックスを使う
  - 例: `onSubmit`、`handleUserRegistration`
- 対になる概念は対になる単語で統一する
  - `open / close`、`start / stop`、`create / delete`、`show / hide`、`add / remove`
- 1文字変数はループカウンタ (`i`, `j`) のみ許容する。それ以外は禁止

---

## 2. シンプルさの徹底

### 原則: 最もシンプルな方法で正しく動くコードを書く。

- 一つの関数は一つのことだけを行う（Single Responsibility）
- 関数の行数は原則30行以内を目安とする。超える場合はサブ関数への分割を検討すること
- ネストは最大3階層まで。超える場合は早期リターンまたは関数抽出で解消する
- 今必要のない機能やインターフェースを先回りして作らない（YAGNI: You Aren't Gonna Need It）
- 抽象化は2回以上の重複が確認されてから行う。1回目は愚直に書く
- 条件分岐が3つ以上に分岐する場合は、マッピングオブジェクトやポリモーフィズムを検討する
- コメントは「なぜ (Why)」を書く。「何を (What)」はコード自体に語らせる
- 使われていないコード、コメントアウトされたコードはコミットしない

---

## 3. 疎結合・高凝集度

### 原則: モジュール間の依存を最小化し、モジュール内の関連性を最大化する。

- 各モジュール/ファイルは明確に定義された一つの責務を持つこと
- モジュール間の依存は、具象ではなくインターフェース（型・契約）を通じて行う
- 循環依存を禁止する。A → B → A のような依存関係が発生した場合は設計を見直すこと
- グローバルな状態（グローバル変数、シングルトン）は原則使用しない。使う場合は仕様書に理由を明記する
- ビジネスロジックは外部依存（DB、API、フレームワーク）から分離する
  - 例: リポジトリパターン、ポート&アダプタ（ヘキサゴナルアーキテクチャ）
- 一つのファイルが複数の無関係な概念を扱っている場合は分割する
- import/依存が5つ以上になったら、そのモジュールの責務が大きすぎないかを見直す

---

## 4. エラーハンドリング

- エラーは握りつぶさない。必ずログ出力、再スロー、またはユーザーへの通知のいずれかを行う
- エラーメッセージは「何が起きたか」「何が期待されていたか」「どうすれば解決できるか」を含める
- 想定外のエラーと業務上のエラーを区別する仕組みを設ける
  - 例: カスタムエラークラス、エラーコード体系
- 外部サービス呼び出しには必ずタイムアウトとリトライ戦略を設定する

---

## 5. テスト

- 新しいビジネスロジックには必ず対応するテストを書く
- テストはアレンジ（準備）→ アクト（実行）→ アサート（検証）の3段構成とする
- テスト名は「何の条件で、何をしたら、どうなるか」を説明する
  - 例: `shouldReturnEmptyListWhenNoOrdersExistForUser`
- 外部依存（DB、API）はモック/スタブに置き換えてテストする
- テストが通らないコードをメインブランチにマージしない
