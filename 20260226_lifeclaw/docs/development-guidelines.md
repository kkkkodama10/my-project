# Development Guidelines

このドキュメントは、プロジェクト全体で遵守すべき開発ガイドラインを定義する。
AIエージェントおよび開発者は、コードの生成・レビュー・修正のすべてにおいてこのガイドラインに従うこと。

> **対象**: 特定のプロジェクトに依存しない、汎用的な開発標準として設計されている。

---

## 目次

1. [設計原則](#1-設計原則)
2. [命名規則](#2-命名規則)
3. [コーディング規約](#3-コーディング規約)
4. [疎結合・高凝集度](#4-疎結合高凝集度)
5. [エラーハンドリング](#5-エラーハンドリング)
6. [テスト方針](#6-テスト方針)
7. [ドキュメント](#7-ドキュメント)
8. [Git運用](#8-git運用)
9. [コードレビュー](#9-コードレビュー)
10. [セキュリティ](#10-セキュリティ)
11. [パフォーマンス](#11-パフォーマンス)
12. [依存関係管理](#12-依存関係管理)

---

## 1. 設計原則

本ガイドライン全体を貫く基本思想を以下に示す。

- **KISS (Keep It Simple, Stupid)**: 最もシンプルな方法で正しく動くコードを書く。
- **YAGNI (You Aren't Gonna Need It)**: 今必要のない機能やインターフェースを先回りして作らない。
- **DRY (Don't Repeat Yourself)**: ただし、抽象化は2回以上の重複が確認されてから行う。1回目は愚直に書く。
- **関心の分離 (Separation of Concerns)**: 各モジュールは明確に定義された一つの責務を持つ。
- **最小驚きの原則 (Principle of Least Astonishment)**: コードを読んだ開発者が「予想通りに動く」と思える設計にする。

---

## 2. 命名規則

### 原則: 可読性を最優先する。長い命名は許容する。

### 2.1 一般ルール

- 変数名・関数名・クラス名は、その役割や意図を読んだだけで理解できる名前にすること。
- 省略形は原則禁止（`usr` → `user`、`btn` → `button`、`msg` → `message`）。
- 業界で広く通用する略語のみ例外とする（`id`、`url`、`http`、`api`、`db` など）。
- 1文字変数はループカウンタ (`i`, `j`, `k`) のみ許容する。それ以外は禁止。

### 2.2 命名パターン

| 対象 | ルール | 例 |
|---|---|---|
| 真偽値 | `is` / `has` / `can` / `should` プレフィックス | `isVisible`, `hasPermission`, `canExecute` |
| コレクション | 複数形 | `users`, `orderItems`, `validationErrors` |
| コールバック / イベント | `on` / `handle` プレフィックス | `onSubmit`, `handleUserRegistration` |
| 定数 | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT`, `DEFAULT_TIMEOUT_MS` |
| クラス / 型 | PascalCase | `UserRepository`, `PaymentService` |
| 関数 / メソッド | camelCase（動詞始まり） | `fetchUserById`, `calculateTotalPrice` |
| 変数 | camelCase（名詞） | `currentUser`, `totalAmount` |
| プライベート | 言語の慣例に従う（`_` プレフィックス等） | `_internalCache` |

### 2.3 対義語の統一

対になる概念は、対になる単語で統一する。チーム内で揺れを作らない。

| 正 | 反 |
|---|---|
| `open` | `close` |
| `start` | `stop` |
| `begin` | `end` |
| `create` | `delete` |
| `add` | `remove` |
| `show` | `hide` |
| `enable` | `disable` |
| `send` | `receive` |
| `request` | `response` |
| `source` | `destination` |

### 2.4 ファイル名・ディレクトリ名

- ファイル名はケバブケース (`kebab-case`) またはプロジェクトのフレームワーク慣例に従う。
- テストファイルは対象ファイルと同名 + `.test` または `.spec` サフィックスとする。
  - 例: `user-service.ts` → `user-service.test.ts`
- ディレクトリ構造は機能単位（feature-based）を推奨する。技術レイヤ単位（layer-based）はプロジェクト規模に応じて選択する。

---

## 3. コーディング規約

### 原則: 最もシンプルな方法で正しく動くコードを書く。

### 3.1 関数設計

- 一つの関数は一つのことだけを行う（Single Responsibility）。
- 関数の行数は原則 **30行以内** を目安とする。超える場合はサブ関数への分割を検討すること。
- 引数は **3つ以下** を推奨する。超える場合はオブジェクト引数を使う。
- 副作用のある関数とない関数を明確に分離する。純粋関数を優先する。

### 3.2 制御構造

- ネストは **最大3階層** まで。超える場合は早期リターン（ガード節）または関数抽出で解消する。
- 条件分岐が3つ以上に分岐する場合は、マッピングオブジェクトやポリモーフィズムを検討する。
- `else` の使用は最小限にし、早期リターンで置き換えられないか検討する。

```
// ❌ 深いネスト
function processOrder(order) {
  if (order) {
    if (order.isValid) {
      if (order.items.length > 0) {
        // 処理
      }
    }
  }
}

// ✅ ガード節で平坦化
function processOrder(order) {
  if (!order) return;
  if (!order.isValid) return;
  if (order.items.length === 0) return;

  // 処理
}
```

### 3.3 コメント

- コメントは **「なぜ (Why)」** を書く。「何を (What)」はコード自体に語らせる。
- TODO / FIXME / HACK コメントには、担当者名と日付（またはチケット番号）を付記する。
  - 例: `// TODO(keita, 2025-06): レート制限の実装 #1234`
- 使われていないコード、コメントアウトされたコードはコミットしない。バージョン管理が履歴を保持する。

### 3.4 型と安全性

- 型のある言語では厳密な型付けを行い、`any` や暗黙的型変換を避ける。
- nullable な値は型レベルで明示し、使用前に必ずチェックする。
- マジックナンバー・マジックストリングは名前付き定数に置き換える。

### 3.5 フォーマット

- フォーマッタ（Prettier、Black、gofmt 等）をプロジェクトに導入し、自動整形をCI/コミットフックで強制する。
- リンター（ESLint、Flake8、golangci-lint 等）を導入し、ルールはプロジェクトの設定ファイルで管理する。
- インデント、改行、括弧のスタイルは **議論しない。ツールに委ねる。**

---

## 4. 疎結合・高凝集度

### 原則: モジュール間の依存を最小化し、モジュール内の関連性を最大化する。

### 4.1 依存関係の制御

- モジュール間の依存は、具象ではなくインターフェース（型・契約）を通じて行う。
- 循環依存を禁止する。`A → B → A` のような依存関係が発生した場合は設計を見直すこと。
- import / 依存が **5つ以上** になったら、そのモジュールの責務が大きすぎないかを見直す。

### 4.2 グローバル状態

- グローバルな状態（グローバル変数、シングルトン）は原則使用しない。
- 使う場合は設計ドキュメントに理由を明記し、レビューで合意を得る。

### 4.3 アーキテクチャ

- ビジネスロジックは外部依存（DB、API、フレームワーク）から分離する。
  - 推奨パターン: リポジトリパターン、ポート&アダプタ（ヘキサゴナルアーキテクチャ）
- 一つのファイルが複数の無関係な概念を扱っている場合は分割する。
- レイヤ間の依存方向は常に **上位（ユースケース）→ 下位（インフラ）** とし、逆方向の依存は依存性逆転の原則（DIP）で解消する。

---

## 5. エラーハンドリング

### 5.1 基本方針

- エラーは握りつぶさない。必ず以下のいずれかを行う:
  1. ログ出力
  2. 再スロー（上位層への伝播）
  3. ユーザーへの通知
- 想定外のエラー（システムエラー）と業務上のエラー（バリデーション失敗等）を区別する仕組みを設ける。
  - 例: カスタムエラークラス、エラーコード体系

### 5.2 エラーメッセージ

エラーメッセージには以下の3点を含める:

1. **何が起きたか** — 現象の説明
2. **何が期待されていたか** — 正常な状態
3. **どうすれば解決できるか** — 次のアクション

```
// ❌ 不十分
"Failed to load data"

// ✅ 十分
"Failed to fetch user profile: API returned 503. Expected 200 OK. Retry after 30 seconds or contact support if the issue persists."
```

### 5.3 外部サービス連携

- 外部サービス呼び出しには必ず **タイムアウト** を設定する。
- リトライ戦略を明示する（回数、間隔、指数バックオフの有無）。
- サーキットブレーカーの導入を検討する（障害の連鎖を防止するため）。

### 5.4 ログ

- ログレベルを適切に使い分ける: `DEBUG` / `INFO` / `WARN` / `ERROR` / `FATAL`。
- 機密情報（パスワード、トークン、個人情報）をログに出力しない。
- 構造化ログ（JSON形式等）を推奨する。検索・集計を容易にするため。

---

## 6. テスト方針

### 6.1 基本ルール

- 新しいビジネスロジックには **必ず** 対応するテストを書く。
- テストが通らないコードをメインブランチにマージしない。
- テストはCI上で自動実行し、全テストのパスをマージ条件とする。

### 6.2 テスト構造

テストはAAA（Arrange-Act-Assert）パターンで記述する:

1. **Arrange（準備）**: テスト対象の初期化、テストデータのセットアップ
2. **Act（実行）**: テスト対象の操作を1つだけ実行
3. **Assert（検証）**: 期待結果との比較

```
// 例
test("shouldReturnEmptyListWhenNoOrdersExistForUser", () => {
  // Arrange
  const userId = "user-001";
  const repository = new InMemoryOrderRepository([]);

  // Act
  const result = repository.findByUserId(userId);

  // Assert
  expect(result).toEqual([]);
});
```

### 6.3 テスト命名

テスト名は **「何の条件で、何をしたら、どうなるか」** を説明する。

| パターン | 例 |
|---|---|
| `should[期待結果]When[条件]` | `shouldReturnEmptyListWhenNoOrdersExistForUser` |
| `[メソッド名]_[条件]_[期待結果]` | `calculateTotal_withEmptyCart_returnsZero` |

### 6.4 テストの分類と戦略

| 分類 | 対象 | 実行速度 | 外部依存 |
|---|---|---|---|
| Unit Test | 関数・クラス単体 | 高速 | なし（モック/スタブ） |
| Integration Test | モジュール間連携 | 中速 | 最小限（テストDB等） |
| E2E Test | ユーザー操作フロー全体 | 低速 | あり |

- **テストピラミッド** を意識する: Unit Test を最も多く、E2E Test を最も少なくする。
- 外部依存（DB、API）はモック/スタブに置き換えてテストする。
- テスト間の実行順序に依存しない独立したテストを書く。

### 6.5 カバレッジ

- カバレッジの数値目標はプロジェクトごとに設定するが、**重要なビジネスロジックは100%カバー** を目指す。
- カバレッジを上げることを目的としたテスト（意味のないアサーション）は書かない。

---

## 7. ドキュメント

### 7.1 コードに近いドキュメント

- README.md: プロジェクト概要、セットアップ手順、開発コマンド一覧を必ず含める。
- CONTRIBUTING.md: コントリビューション手順、ブランチ戦略、コミットルールを記載する。
- CHANGELOG.md: ユーザー影響のある変更を記録する。Keep a Changelog 形式を推奨する。
- ADR (Architecture Decision Records): アーキテクチャ上の重要な意思決定を `docs/adr/` に記録する。

### 7.2 API ドキュメント

- 外部公開APIにはOpenAPI (Swagger) 等の仕様書を用意する。
- 仕様書はコードから自動生成できる仕組みを推奨する。
- リクエスト例・レスポンス例を必ず含める。

---

## 8. Git運用

### 8.1 ブランチ戦略

メインブランチを常にデプロイ可能な状態に保つ。

| ブランチ | 用途 | 命名規則 |
|---|---|---|
| `main` | 本番環境相当。常に安定。 | — |
| `develop` | 開発統合（使用する場合） | — |
| `feature/*` | 新機能開発 | `feature/add-user-authentication` |
| `bugfix/*` | バグ修正 | `bugfix/fix-login-redirect-loop` |
| `hotfix/*` | 本番緊急修正 | `hotfix/patch-payment-null-error` |
| `chore/*` | 設定変更・リファクタリング等 | `chore/update-eslint-config` |
| `docs/*` | ドキュメント更新 | `docs/add-api-reference` |

- ブランチ名は **ケバブケース** で、内容が分かる簡潔な説明を含める。
- 長期間放置されたブランチは定期的に整理する。

### 8.2 コミットメッセージ

[Conventional Commits](https://www.conventionalcommits.org/) に準拠する。

```
<type>(<scope>): <subject>

<body>

<footer>
```

#### type 一覧

| type | 説明 |
|---|---|
| `feat` | 新機能 |
| `fix` | バグ修正 |
| `docs` | ドキュメントのみの変更 |
| `style` | コードの意味に影響しない変更（空白、フォーマット等） |
| `refactor` | バグ修正も機能追加もしないコード変更 |
| `perf` | パフォーマンス改善 |
| `test` | テストの追加・修正 |
| `chore` | ビルドプロセスやツール設定の変更 |
| `ci` | CI設定の変更 |
| `revert` | 過去のコミットの取り消し |

#### コミットメッセージの例

```
feat(auth): ソーシャルログイン機能を追加

Google / GitHub OAuth2 による認証フローを実装。
既存のメール認証と共存可能な設計。

Refs: #456
```

```
fix(cart): 数量0の商品が注文確定できる問題を修正

数量バリデーションがカート更新時のみで、
注文確定APIに欠落していたため追加。

Fixes: #789
```

#### ルール

- subject は **50文字以内** を目標とする。
- body で「なぜこの変更が必要か」を説明する。
- 1つのコミットは **1つの論理的変更** に対応させる。リファクタリングと機能追加を混ぜない。
- `WIP` コミットは個人ブランチでのみ許容し、マージ前にスカッシュする。

### 8.3 プルリクエスト / マージリクエスト

- PRタイトルはコミットメッセージと同じConventional Commits形式を推奨する。
- PR本文には以下を含める:
  - **変更の概要**: 何をなぜ変更したか
  - **テスト方法**: どのように動作確認したか
  - **影響範囲**: 他の機能への影響の有無
  - **関連チケット**: Issue番号やチケットへのリンク
- PRのサイズは **変更行数300行以下** を目安とする。超える場合は分割を検討する。
- マージ前に以下を満たすこと:
  - CIが全てパス
  - 最低1名のレビュー承認
  - コンフリクトが解消済み

### 8.4 タグ / リリース

- リリースには [Semantic Versioning](https://semver.org/) を使用する: `MAJOR.MINOR.PATCH`
  - **MAJOR**: 後方互換性のない変更
  - **MINOR**: 後方互換性のある機能追加
  - **PATCH**: 後方互換性のあるバグ修正
- リリースノートには、ユーザーに影響する変更を箇条書きで記載する。

---

## 9. コードレビュー

### 9.1 レビューの目的

- バグの早期発見
- 設計・可読性の向上
- チーム内の知識共有

### 9.2 レビューのマナー

- コードを批判する。人を批判しない。
- 「なぜ」を添えた具体的な指摘をする。
- 良いコードには積極的に称賛する。
- 提案（suggestion）と必須修正（must fix）を区別する。
  - 例: `[nit]` — 些細な指摘（修正任意）、`[must]` — マージ前に修正必須

### 9.3 レビューチェックリスト

レビュー時に以下の観点を確認する:

- [ ] 命名規則に従っているか
- [ ] 関数の責務が明確で、行数が適切か
- [ ] エラーハンドリングが適切か
- [ ] テストが追加・更新されているか
- [ ] セキュリティ上の問題がないか（インジェクション、認証漏れ等）
- [ ] パフォーマンス上の明らかな問題がないか
- [ ] 不要なコード、デバッグコードが残っていないか

---

## 10. セキュリティ

### 10.1 基本原則

- **最小権限の原則**: 必要最小限の権限のみを付与する。
- **デフォルト拒否**: 明示的に許可されていないものは拒否する。
- **防御的プログラミング**: 入力は常に信頼しない。

### 10.2 必須対策

- ユーザー入力は必ずバリデーション・サニタイズする。
- SQLインジェクション対策としてプリペアドステートメント/パラメータバインディングを使う。
- 機密情報（APIキー、パスワード、トークン）をソースコードにハードコードしない。環境変数またはシークレット管理サービスを使う。
- `.env` ファイル、秘密鍵ファイルは `.gitignore` に含め、リポジトリにコミットしない。
- 認証・認可の処理は自作せず、実績のあるライブラリ/フレームワークを使用する。
- 依存パッケージの脆弱性スキャンをCIに組み込む（`npm audit`、`pip audit`、Dependabot等）。

---

## 11. パフォーマンス

### 11.1 基本方針

- **推測するな、計測せよ。** パフォーマンス最適化は計測に基づいて行う。
- 早すぎる最適化は避ける。まず正しく動くコードを書き、ボトルネックが判明してから最適化する。

### 11.2 注意すべきパターン

- N+1クエリ問題を避ける。バッチ取得またはJOINを使う。
- 不要な再計算を避ける。必要に応じてキャッシュやメモ化を使う。
- 大量データの処理はページネーションまたはストリーミングで行う。
- 重い処理は非同期化・バックグラウンドジョブへの切り出しを検討する。

---

## 12. 依存関係管理

- 依存パッケージのバージョンは **ロックファイル** で固定する（`package-lock.json`、`poetry.lock`、`go.sum` 等）。
- ロックファイルは必ずリポジトリにコミットする。
- 依存パッケージの追加時は、ライセンス・メンテナンス状況・セキュリティを確認する。
- 定期的に依存パッケージを更新し、脆弱性対応を行う。
- 使われなくなった依存パッケージは速やかに削除する。

---

## 改訂履歴

| 日付 | バージョン | 内容 |
|---|---|---|
| YYYY-MM-DD | 1.0.0 | 初版作成 |
